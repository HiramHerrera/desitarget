#!/usr/bin/env python

from __future__ import print_function, division

import os, sys
import numpy as np

from desitarget.imagefootprint import pixweight

#import warnings
#warnings.simplefilter('error')

import multiprocessing
nproc = multiprocessing.cpu_count() // 2

from desiutil.log import get_logger
log = get_logger()

from argparse import ArgumentParser
ap = ArgumentParser()
ap.add_argument("src", 
                help='Legacy Surveys Data Release root directory (e.g. /global/project/projectdirs/cosmo/data/legacysurvey/dr4/ for DR4 at NERSC)')
ap.add_argument("dest", 
                help='Output file name to write map of HEALPixel weights in the NESTED scheme (e.g. /project/projectdirs/desi/target/catalogs/pixweight-dr4-0.20.0.fits)')
ap.add_argument("--nside", type=int, 
                help='The resolution (HEALPixel nside number) at which to build the map (defaults to 256)',
                default="256")
ap.add_argument("--density", type=int,
                help='Number of points per sq. deg. at which to Monte Carlo the imaging masks (defaults to 10million)',
                default="10000000")
ap.add_argument("--outplot",
                help='Output file name to which to write a plot of the map',
                default=None)
ap.add_argument("--numproc", type=int,
                help='number of concurrent processes to use [{}]'.format(nproc),
                default=nproc)

ns = ap.parse_args()

if not os.path.exists(ns.src):
    log.critical('Input directory does not exist: {}'.format(ns.src))
    sys.exit(1)

log.info('running on {} processors'.format(ns.numproc))

_ = pixweight(nside=ns.nside, density=ns.density, numproc=ns.numproc, outfile=ns.dest, outplot=ns.outplot, drdir=ns.src)

log.info('wrote map of HEALPixel weights (in the nested scheme) to {}'.format(ns.dest))

    npix = hp.nside2npix(nside)
    pix_cnt = np.bincount(hpxinfo['HPXPIXEL'], weights=hpxinfo['HPXCOUNT'], minlength=npix)
    
    #ADM we know the area of HEALPixels at this nside, so we know what the count SHOULD be
    expected_cnt = hp.nside2pixarea(nside,degrees=True)*density
    #ADM create a weight map based on the actual counts divided by the expected counts
    pix_weight = pix_cnt/expected_cnt

    #ADM write out results, if requested
    if outfile is not None:
        log.info('Writing pixel map to {}'.format(outfile))
        #ADM write information indicating HEALPix setup to file header
        #ADM include desitarget version as a check in case something changes
        import fitsio
        from desiutil import depend
        from . import __version__ as desitarget_version
        hdr = fitsio.FITSHDR()
        depend.setdep(hdr, 'desitarget', desitarget_version)
        hdr['DENSITY'] = density
        hdr['HPXNSIDE'] = nside
        hdr['HPXNEST'] = True
        fitsio.write(outfile, pix_weight, extname='PIXWEIGHTS', header=hdr, clobber=True)

    #ADM if outplot was passed, make a plot of the final mask in Mollweide projection
    if outplot is not None:
        log.info('Plotting pixel map and writing to {}'.format(outplot))
        hp.mollview(pix_weight, nest=True)
        plt.savefig(outplot)

    log.info('Done...t={:.1f}s'.format(time()-start))

    return qinfo, pix_weight

