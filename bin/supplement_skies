#!/usr/bin/env python

from desitarget.skyfibers import supplement_skies, density_of_sky_fibers
from desitarget import io
from desitarget.geomask import bundle_bricks

import numpy as np
import healpy as hp
import fitsio

#import warnings
#warnings.simplefilter('error')

import multiprocessing
nproc = multiprocessing.cpu_count() // 2
# ADM default HEALPix Nside used throughout desitarget.
# ADM don't confuse this with the ns.nside parallelization input that is parsed below!!!
nside = io.desitarget_nside()

from desiutil.log import get_logger
log = get_logger()

from argparse import ArgumentParser
ap = ArgumentParser(description='Generate supplemental sky locations using Gaia-G-band avoidance (for regions beyond the Legacy Surveys)')
ap.add_argument("source",
                help="Input sky targets file (e.g. /project/projectdirs/desi/target/catalogs/dr8/0.31.0/skies/skies-dr8-0.31.0.fits). Used purely to set the minimum allowed OBJID.")
ap.add_argument("dest",
                help="Output supplemental sky targets file (e.g. /project/projectdirs/desi/target/catalogs/supp-skies-dr4-0.20.0.fits)")
ap.add_argument("--nskiespersqdeg", type=float,
                help="Number of sky locations to generate per sq. deg. (don't pass to read the default from desimodel.io with a 4x margin)",
                default=None)
ap.add_argument("--numproc", type=int,
                help="number of concurrent processes to use (defaults to [{}])".format(nproc),
                default=nproc)
ap.add_argument("--gaiadir", type=str,
                help="Pass to set the GAIA_DIR environment variable directly in the code (i.e. the input directory that stores Gaia files)",
                default=None)
ap.add_argument('--nside', type=int,
                help="Process supplemental skies in HEALPixels at this resolution (defaults to None). See also the 'healpixels' input flag",
                default=None)
ap.add_argument('--healpixels',
                help="HEALPixels corresponding to `nside` (e.g. '6,21,57'). Only process files that touch these pixels and return targets within these pixels",
                default=None)
ap.add_argument("--bundlefiles", type=int,
                help="(overrides all options but `source`) print slurm script to parallelize by sending (any) integer. This is an integer rather than boolean for consistency with select_targets.",
                default=None)
ap.add_argument("--mindec", type=float,
                help="Minimum declination to include in output file (degrees; defaults to [-90])",
                default=-90.)
ap.add_argument("--mingalb", type=float,
                help="Closest latitude to Galactic plane to output for NON-LEGACY-SURVEYS sources (e.g. send 10 to limit to areas beyond -10o <= b < 10o; defaults to [0])",
                default=0.)
ap.add_argument("--radius", type=float,
                help="Radius at which to avoid (all) Gaia sources (arcseconds; defaults to [2])",
                default=2.)

ns = ap.parse_args()

# ADM determine the maximum OBJID in the file that's being supplemented.
# ADM 1 + this will be the minimum allowed OBJID for supplemental skies.
minobjid = np.max(fitsio.read(ns.source, columns="BRICK_OBJID"))

# ADM if the GAIA directory was passed, set it...
gaiadir = ns.gaiadir
if gaiadir is None:
    # ADM ...otherwise retrieve it from the environment variable.
    from desitarget.gaiamatch import _get_gaia_dir
    gaiadir = _get_gaia_dir()

# ADM if needed, determine the minimum density of sky fibers to generate.
nskiespersqdeg = ns.nskiespersqdeg
if nskiespersqdeg is None:
    nskiespersqdeg = density_of_sky_fibers(margin=4)
log.info('Generating sky positions at a density of {}'.format(nskiespersqdeg))

# ADM build the list of command line arguments as
# ADM bundlefiles potentially needs to know about them.
extra = " --numproc {}".format(ns.numproc)
extra += " --nskiespersqdeg {}".format(nskiespersqdeg)
extra += " --gaiadir {}".format(gaiadir)
nsdict = vars(ns)
for nskey in "mindec", "mingalb", "radius":
    extra += " --{} {}".format(nskey, nsdict[nskey])

# ADM parse the list of HEALPixels in which to run.
pixlist = ns.healpixels
if pixlist is not None:
    pixlist = [int(pix) for pix in pixlist.split(',')]

# ADM only proceed if we're not writing a slurm script.
if ns.bundlefiles is None:
    # ADM generate the supplemental sky locations.
    skies = supplement_skies(nskiespersqdeg=nskiespersqdeg, numproc=ns.numproc,
                             gaiadir=gaiadir, radius=ns.radius, nside=ns.nside,
                             pixlist=pixlist, mindec=ns.mindec,
                             mingalb=ns.mingalb, minobjid=minobjid)

    # ADM extra header keywords for the output fits file.
    extra = {k: v for k, v in zip(["radius", "mindec", "mingalb"],
                                  [ns.radius, ns.mindec, ns.mingalb])}

    io.write_skies(ns.dest, skies, supp=True, indir=gaiadir,
                   nside=nside, nskiespersqdeg=nskiespersqdeg,
                   extra=extra, nsidefile=ns.nside, hpxlist=pixlist)

    log.info('{} supplemental skies written to {}'.format(len(skies), ns.dest))
else:
    # ADM if the bundlefiles option was sent, call the slurming code.
    bundle_bricks([0], ns.bundlefiles, ns.nside, gather=False,
                  prefix='supp-skies', surveydirs=[ns.source], extra=extra)

