#!/usr/bin/env python

'''
merge mock targets and truth from individual pixels into summary tables
'''

#- Parse args at the start so that --help will work from login node without MPI
from __future__ import absolute_import, division, print_function
import argparse

parser = argparse.ArgumentParser(usage = "{prog} [options]")
parser.add_argument("--mockdir", type=str, required=True, help="input mock directory")
parser.add_argument("--outdir", type=str,  help="output directory")
parser.add_argument("--force", action="store_true", help="rerun even if output files exist")
# parser.add_argument("-v", "--verbose", action="store_true", help="some flag")
args = parser.parse_args()
if args.outdir is None:
    args.outdir = args.mockdir

#- then establish MPI before SLURM thinks we're dead
from mpi4py import MPI

import os, sys, glob
import numpy as np
import fitsio

def merge_table_data(infiles, ext=1):
    '''
    Return concatenated tables from a set of input files
    
    Args:
        infiles: list of input fits files
    
    Options:
        ext: extension name or number

    Returns:
        concatenated table from input files
    '''
    data = [fitsio.read(x, ext) for x in infiles]
    return np.hstack(data)

def merge_files(comm, globname, ext, outfile):
    '''
    parallel merge tables from individual files into and output file
    
    Args:
        comm: MPI communicator object
        globname (str): glob of files to combine (e.g. '*/blat-*.fits')
        ext (str or int): FITS file extension name or number
        outfile (str): output file to write
    '''
    size = comm.Get_size()
    rank = comm.Get_rank()
    if rank == 0:
        infiles = sorted(glob.glob(globname))
    else:
        infiles = None

    infiles = comm.bcast(infiles, root=0)

    #- Each rank reads and combines a different set of files
    data = merge_table_data(infiles[rank::size], ext=ext)
    data = comm.gather(data, root=0)

    if rank == 0:
        print('Writing', outfile)
        data = np.hstack(data)
        header = fitsio.read_header(infiles[0], ext)
        tmpout = outfile + '.tmp'
        fitsio.write(tmpout, data, header=header, extname=ext, clobber=True)
        os.rename(tmpout, outfile)

#-------------------------------------------------------------------------
comm = MPI.COMM_WORLD
size = comm.Get_size()
rank = comm.Get_rank()

#- Use rank 0 to check pre-existing files to avoid N>>1 ranks hitting the disk
todo = dict()
if rank == 0:
    todo['sky'] = not os.path.exists(args.outdir+'/sky.fits') or args.force
    todo['stddark'] = not os.path.exists(args.outdir+'/standards-dark.fits') or args.force
    todo['stdbright'] = not os.path.exists(args.outdir+'/standards-bright.fits') or args.force
    todo['targets'] = not os.path.exists(args.outdir+'/targets.fits') or args.force
    todo['truth'] = not os.path.exists(args.outdir+'/truth.fits') or args.force
    todo['mtl'] = not os.path.exists(args.outdir+'/mtl.fits') or args.force
else:
    todo = None

todo = comm.bcast(todo, root=0)    

if todo['sky']:
    merge_files(comm, args.mockdir+'/*/*/sky-*.fits', 'SKY', args.outdir+'/sky.fits')

if todo['stddark']:
    merge_files(comm, args.mockdir+'/*/*/standards-dark*.fits', 'STD', args.outdir+'/standards-dark.fits')

if todo['stdbright']:
    merge_files(comm, args.mockdir+'/*/*/standards-bright*.fits', 'STD', args.outdir+'/standards-bright.fits')

if todo['targets']:
    merge_files(comm, args.mockdir+'/*/*/targets-*.fits', 'TARGETS', args.outdir+'/targets.fits')

if todo['truth']:
    merge_files(comm, args.mockdir+'/*/*/truth-*.fits', 'TRUTH', args.outdir+'/truth.fits')

#- Make initial merged target list (MTL) using rank 0
if rank == 0 and todo['mtl']:
    from desitarget import mtl
    out_mtl = os.path.join(args.outdir, 'mtl.fits')
    print('Generating merged target list', out_mtl)
    targets = fitsio.read(args.outdir+'/targets.fits')
    mtl = mtl.make_mtl(targets)
    tmpout = out_mtl+'.tmp'
    mtl.meta['EXTNAME'] = 'MTL'
    mtl.write(tmpout, overwrite=True, format='fits')
    # fitsio.write(tmpout, mtl, extname='MTL', clobber=True)
    os.rename(tmpout, out_mtl)





