"""
    This file knjow how to write a TS catalogue.

"""

# everybody likes np
import numpy as np 
from astropy.io import fits
import fitsio
import os, re

def read_mock_durham(filename):
    """
    Args:
    filename: filename of the hdf5 file storing lightconedata.
    
    Returns:
    target_id: 1D numpy array, array of unique target IDs associated to the magnitudes. 
    ra : 1D numpy array, Right Ascension
    dec: 1D numpy array, declination
    g_mags: 1D numpy array, magnitudes in g band.
    r_mags: 1D numpy array, magnitudes in g band.
    z_mags: 1D numpy array, magnitudes in g band.
    returns 1D numpy array of a subset from target_id.
    
    """
    raise NotImplementedError("Read and convert a Durham mock to DECALS schema")

    fin = h5py.File(filename, "r") 
    data = fin.require_group('/Data') 
    ra = data['ra'].value                                                                                    
    dec = data['dec'].value                                                                                  
    gal_id_string = data['GalaxyID'].value # these are string values, not integers!                               
    g_mags = data['appDgo_tot_ext'].value                                                                        
    r_mags = data['appDro_tot_ext'].value                                                                        
    z_mags = data['appDzo_tot_ext'].value  
    n_gals = 0
    n_gals = ra.size
    target_id = np.arange(n_gals)

def get_tractor_files(data_release_dir):
    from glob import glob
    return sorted(glob(data_release_dir+'/tractor/???/tractor-*.fits'))

def read_tractor(filename):
    """ 
        Read a tractor catalogue. Always the latest DR. 
        
        Args:
            filename: a file name of one tractor file

        Returns:
            ndarray with the tractor schema, uppercase field names.
    """
    ### return fits.getdata(filename, 1)
    return fitsio.read(filename, 1, upper=True)

def write_targets(filename, data, tsbits):
    """ 
        Write a target catalogue. 
        
        Args:
            filename : a file name of one tractor file.
                 File contains the original tractor catalogue fields,
                 with target selection mask added as 'TSBITS'

            data     : the original tractor catalogue

            tsbits   : the target selection bitmask, a 1d integer ndarray
                    generated by :ref:`desitarget.targetmask`

        Notes:
            This function raises an exception if the file already exists.
            Depending on the use case, this function may need to be split
            into two functions: one appends the column, another writes the
            fits file.
        
    """
    # FIXME: assert data and tsbits schema
    #
    # add a column name
    tsbits = tsbits.view(dtype=[('TSBITS', tsbits.dtype)])

    # do not use a context manager as
    # the fits context manager doesn't flush.
    with file(filename, mode='w') as f:
        ff = fits.open(f, mode='ostream')

        # OK we will follow the rules at
        # https://pythonhosted.org/pyfits/users_guide/users_table.html
        # to merge two tables.
        #
        hdu1 = fits.BinTableHDU(data)
        hdu2 = fits.BinTableHDU(tsbits)

        columns = hdu1.columns + hdu2.columns

        hdu = fits.BinTableHDU.from_columns(columns)

        ff.append(hdu)

        # flush and close are both required.
        ff.flush()
        ff.close()    

def iter_tractor(root):
    """ Iterator all tractor files in a directory.

        Parameters
        ----------
        root : string
            Path to start looking
        
        Returns
        -------
        An iterator of (brickname, filename).

        Examples
        --------
        >>> for brickname, filename in iter_tractor('./'):
        >>>     print(brickname, filename)

    """
    def parse_filename(filename):
        """parse filename to check if this is a tractor brick file;
        returns brickname if it is, otherwise raises ValueError"""
        if not filename.endswith('.fits'): raise ValueError
        #- match filename tractor-0003p027.fits -> brickname 0003p027
        match = re.search('tractor-(\d{4}[pm]\d{3})\.fits', 
                os.path.basename(filename))

        if not match: raise ValueError

        brickname = match.group(1)
        return brickname

    for roots, dirnames, filenames in os.walk(root, followlinks=True):
        ### print filenames
        for filename in filenames:
            try:
                yield parse_filename(filename), filename
            except ValueError:
                #- not a brick file but that's ok; keep going
                pass 
    
